/**
 * Open API
 * Open API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: liuxiaobin@chainge.finance
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.5.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/OpenAPICrossChainInquiryParameters.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

OpenAPICrossChainInquiryParameters::OpenAPICrossChainInquiryParameters() {
  m_Amount = 0.0;
  m_AmountIsSet = false;
  m_FeeLevel = 0;
  m_FeeLevelIsSet = false;
  m_FromChain = utility::conversions::to_string_t("");
  m_FromChainIsSet = false;
  m_ToChain = utility::conversions::to_string_t("");
  m_ToChainIsSet = false;
  m_Token = utility::conversions::to_string_t("");
  m_TokenIsSet = false;
}

OpenAPICrossChainInquiryParameters::~OpenAPICrossChainInquiryParameters() {}

void OpenAPICrossChainInquiryParameters::validate() {
  // TODO: implement validation
}

web::json::value OpenAPICrossChainInquiryParameters::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_AmountIsSet) {
    val[utility::conversions::to_string_t(U("amount"))] =
        ModelBase::toJson(m_Amount);
  }
  if (m_FeeLevelIsSet) {
    val[utility::conversions::to_string_t(U("feeLevel"))] =
        ModelBase::toJson(m_FeeLevel);
  }
  if (m_FromChainIsSet) {
    val[utility::conversions::to_string_t(U("fromChain"))] =
        ModelBase::toJson(m_FromChain);
  }
  if (m_ToChainIsSet) {
    val[utility::conversions::to_string_t(U("toChain"))] =
        ModelBase::toJson(m_ToChain);
  }
  if (m_TokenIsSet) {
    val[utility::conversions::to_string_t(U("token"))] =
        ModelBase::toJson(m_Token);
  }

  return val;
}

bool OpenAPICrossChainInquiryParameters::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("amount")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("amount")));
    if (!fieldValue.is_null()) {
      double refVal_setAmount;
      ok &= ModelBase::fromJson(fieldValue, refVal_setAmount);
      setAmount(refVal_setAmount);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("feeLevel")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("feeLevel")));
    if (!fieldValue.is_null()) {
      int32_t refVal_setFeeLevel;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFeeLevel);
      setFeeLevel(refVal_setFeeLevel);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromChain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromChain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromChain);
      setFromChain(refVal_setFromChain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("toChain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("toChain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToChain);
      setToChain(refVal_setToChain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("token")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("token")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToken;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToken);
      setToken(refVal_setToken);
    }
  }
  return ok;
}

void OpenAPICrossChainInquiryParameters::toMultipart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_AmountIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("amount")), m_Amount));
  }
  if (m_FeeLevelIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("feeLevel")),
        m_FeeLevel));
  }
  if (m_FromChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromChain")),
        m_FromChain));
  }
  if (m_ToChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("toChain")),
        m_ToChain));
  }
  if (m_TokenIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("token")), m_Token));
  }
}

bool OpenAPICrossChainInquiryParameters::fromMultiPart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("amount")))) {
    double refVal_setAmount;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("amount"))),
        refVal_setAmount);
    setAmount(refVal_setAmount);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("feeLevel")))) {
    int32_t refVal_setFeeLevel;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("feeLevel"))),
        refVal_setFeeLevel);
    setFeeLevel(refVal_setFeeLevel);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromChain")))) {
    utility::string_t refVal_setFromChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromChain"))),
        refVal_setFromChain);
    setFromChain(refVal_setFromChain);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("toChain")))) {
    utility::string_t refVal_setToChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("toChain"))),
        refVal_setToChain);
    setToChain(refVal_setToChain);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("token")))) {
    utility::string_t refVal_setToken;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("token"))),
        refVal_setToken);
    setToken(refVal_setToken);
  }
  return ok;
}

double OpenAPICrossChainInquiryParameters::getAmount() const {
  return m_Amount;
}

void OpenAPICrossChainInquiryParameters::setAmount(double value) {
  m_Amount = value;
  m_AmountIsSet = true;
}

bool OpenAPICrossChainInquiryParameters::amountIsSet() const {
  return m_AmountIsSet;
}

void OpenAPICrossChainInquiryParameters::unsetAmount() {
  m_AmountIsSet = false;
}
int32_t OpenAPICrossChainInquiryParameters::getFeeLevel() const {
  return m_FeeLevel;
}

void OpenAPICrossChainInquiryParameters::setFeeLevel(int32_t value) {
  m_FeeLevel = value;
  m_FeeLevelIsSet = true;
}

bool OpenAPICrossChainInquiryParameters::feeLevelIsSet() const {
  return m_FeeLevelIsSet;
}

void OpenAPICrossChainInquiryParameters::unsetFeeLevel() {
  m_FeeLevelIsSet = false;
}
utility::string_t OpenAPICrossChainInquiryParameters::getFromChain() const {
  return m_FromChain;
}

void OpenAPICrossChainInquiryParameters::setFromChain(
    const utility::string_t &value) {
  m_FromChain = value;
  m_FromChainIsSet = true;
}

bool OpenAPICrossChainInquiryParameters::fromChainIsSet() const {
  return m_FromChainIsSet;
}

void OpenAPICrossChainInquiryParameters::unsetFromChain() {
  m_FromChainIsSet = false;
}
utility::string_t OpenAPICrossChainInquiryParameters::getToChain() const {
  return m_ToChain;
}

void OpenAPICrossChainInquiryParameters::setToChain(
    const utility::string_t &value) {
  m_ToChain = value;
  m_ToChainIsSet = true;
}

bool OpenAPICrossChainInquiryParameters::toChainIsSet() const {
  return m_ToChainIsSet;
}

void OpenAPICrossChainInquiryParameters::unsetToChain() {
  m_ToChainIsSet = false;
}
utility::string_t OpenAPICrossChainInquiryParameters::getToken() const {
  return m_Token;
}

void OpenAPICrossChainInquiryParameters::setToken(
    const utility::string_t &value) {
  m_Token = value;
  m_TokenIsSet = true;
}

bool OpenAPICrossChainInquiryParameters::tokenIsSet() const {
  return m_TokenIsSet;
}

void OpenAPICrossChainInquiryParameters::unsetToken() { m_TokenIsSet = false; }
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
