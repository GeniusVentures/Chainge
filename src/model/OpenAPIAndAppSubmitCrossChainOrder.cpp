/**
 * Open API
 * Open API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: liuxiaobin@chainge.finance
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.5.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/OpenAPIAndAppSubmitCrossChainOrder.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

OpenAPIAndAppSubmitCrossChainOrder::OpenAPIAndAppSubmitCrossChainOrder() {
  m_CertHash = utility::conversions::to_string_t("");
  m_CertHashIsSet = false;
  m_EvmAddress = utility::conversions::to_string_t("");
  m_EvmAddressIsSet = false;
  m_FeeLevel = 0;
  m_FeeLevelIsSet = false;
  m_FromAddress = utility::conversions::to_string_t("");
  m_FromAddressIsSet = false;
  m_FromAmount = 0.0;
  m_FromAmountIsSet = false;
  m_FromChain = utility::conversions::to_string_t("");
  m_FromChainIsSet = false;
  m_FromToken = utility::conversions::to_string_t("");
  m_FromTokenIsSet = false;
  m_ToChain = utility::conversions::to_string_t("");
  m_ToChainIsSet = false;
}

OpenAPIAndAppSubmitCrossChainOrder::~OpenAPIAndAppSubmitCrossChainOrder() {}

void OpenAPIAndAppSubmitCrossChainOrder::validate() {
  // TODO: implement validation
}

web::json::value OpenAPIAndAppSubmitCrossChainOrder::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_CertHashIsSet) {
    val[utility::conversions::to_string_t(U("certHash"))] =
        ModelBase::toJson(m_CertHash);
  }
  if (m_EvmAddressIsSet) {
    val[utility::conversions::to_string_t(U("evmAddress"))] =
        ModelBase::toJson(m_EvmAddress);
  }
  if (m_FeeLevelIsSet) {
    val[utility::conversions::to_string_t(U("feeLevel"))] =
        ModelBase::toJson(m_FeeLevel);
  }
  if (m_FromAddressIsSet) {
    val[utility::conversions::to_string_t(U("fromAddress"))] =
        ModelBase::toJson(m_FromAddress);
  }
  if (m_FromAmountIsSet) {
    val[utility::conversions::to_string_t(U("fromAmount"))] =
        ModelBase::toJson(m_FromAmount);
  }
  if (m_FromChainIsSet) {
    val[utility::conversions::to_string_t(U("fromChain"))] =
        ModelBase::toJson(m_FromChain);
  }
  if (m_FromTokenIsSet) {
    val[utility::conversions::to_string_t(U("fromToken"))] =
        ModelBase::toJson(m_FromToken);
  }
  if (m_ToChainIsSet) {
    val[utility::conversions::to_string_t(U("toChain"))] =
        ModelBase::toJson(m_ToChain);
  }

  return val;
}

bool OpenAPIAndAppSubmitCrossChainOrder::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("certHash")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("certHash")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setCertHash;
      ok &= ModelBase::fromJson(fieldValue, refVal_setCertHash);
      setCertHash(refVal_setCertHash);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("evmAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("evmAddress")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setEvmAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setEvmAddress);
      setEvmAddress(refVal_setEvmAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("feeLevel")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("feeLevel")));
    if (!fieldValue.is_null()) {
      int32_t refVal_setFeeLevel;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFeeLevel);
      setFeeLevel(refVal_setFeeLevel);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromAddress")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromAddress);
      setFromAddress(refVal_setFromAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromAmount")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromAmount")));
    if (!fieldValue.is_null()) {
      double refVal_setFromAmount;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromAmount);
      setFromAmount(refVal_setFromAmount);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromChain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromChain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromChain);
      setFromChain(refVal_setFromChain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromToken")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromToken")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromToken;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromToken);
      setFromToken(refVal_setFromToken);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("toChain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("toChain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToChain);
      setToChain(refVal_setToChain);
    }
  }
  return ok;
}

void OpenAPIAndAppSubmitCrossChainOrder::toMultipart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_CertHashIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("certHash")),
        m_CertHash));
  }
  if (m_EvmAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("evmAddress")),
        m_EvmAddress));
  }
  if (m_FeeLevelIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("feeLevel")),
        m_FeeLevel));
  }
  if (m_FromAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromAddress")),
        m_FromAddress));
  }
  if (m_FromAmountIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromAmount")),
        m_FromAmount));
  }
  if (m_FromChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromChain")),
        m_FromChain));
  }
  if (m_FromTokenIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromToken")),
        m_FromToken));
  }
  if (m_ToChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("toChain")),
        m_ToChain));
  }
}

bool OpenAPIAndAppSubmitCrossChainOrder::fromMultiPart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("certHash")))) {
    utility::string_t refVal_setCertHash;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("certHash"))),
        refVal_setCertHash);
    setCertHash(refVal_setCertHash);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("evmAddress")))) {
    utility::string_t refVal_setEvmAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("evmAddress"))),
        refVal_setEvmAddress);
    setEvmAddress(refVal_setEvmAddress);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("feeLevel")))) {
    int32_t refVal_setFeeLevel;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("feeLevel"))),
        refVal_setFeeLevel);
    setFeeLevel(refVal_setFeeLevel);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromAddress")))) {
    utility::string_t refVal_setFromAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromAddress"))),
        refVal_setFromAddress);
    setFromAddress(refVal_setFromAddress);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromAmount")))) {
    double refVal_setFromAmount;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromAmount"))),
        refVal_setFromAmount);
    setFromAmount(refVal_setFromAmount);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromChain")))) {
    utility::string_t refVal_setFromChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromChain"))),
        refVal_setFromChain);
    setFromChain(refVal_setFromChain);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromToken")))) {
    utility::string_t refVal_setFromToken;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromToken"))),
        refVal_setFromToken);
    setFromToken(refVal_setFromToken);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("toChain")))) {
    utility::string_t refVal_setToChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("toChain"))),
        refVal_setToChain);
    setToChain(refVal_setToChain);
  }
  return ok;
}

utility::string_t OpenAPIAndAppSubmitCrossChainOrder::getCertHash() const {
  return m_CertHash;
}

void OpenAPIAndAppSubmitCrossChainOrder::setCertHash(
    const utility::string_t &value) {
  m_CertHash = value;
  m_CertHashIsSet = true;
}

bool OpenAPIAndAppSubmitCrossChainOrder::certHashIsSet() const {
  return m_CertHashIsSet;
}

void OpenAPIAndAppSubmitCrossChainOrder::unsetCertHash() {
  m_CertHashIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitCrossChainOrder::getEvmAddress() const {
  return m_EvmAddress;
}

void OpenAPIAndAppSubmitCrossChainOrder::setEvmAddress(
    const utility::string_t &value) {
  m_EvmAddress = value;
  m_EvmAddressIsSet = true;
}

bool OpenAPIAndAppSubmitCrossChainOrder::evmAddressIsSet() const {
  return m_EvmAddressIsSet;
}

void OpenAPIAndAppSubmitCrossChainOrder::unsetEvmAddress() {
  m_EvmAddressIsSet = false;
}
int32_t OpenAPIAndAppSubmitCrossChainOrder::getFeeLevel() const {
  return m_FeeLevel;
}

void OpenAPIAndAppSubmitCrossChainOrder::setFeeLevel(int32_t value) {
  m_FeeLevel = value;
  m_FeeLevelIsSet = true;
}

bool OpenAPIAndAppSubmitCrossChainOrder::feeLevelIsSet() const {
  return m_FeeLevelIsSet;
}

void OpenAPIAndAppSubmitCrossChainOrder::unsetFeeLevel() {
  m_FeeLevelIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitCrossChainOrder::getFromAddress() const {
  return m_FromAddress;
}

void OpenAPIAndAppSubmitCrossChainOrder::setFromAddress(
    const utility::string_t &value) {
  m_FromAddress = value;
  m_FromAddressIsSet = true;
}

bool OpenAPIAndAppSubmitCrossChainOrder::fromAddressIsSet() const {
  return m_FromAddressIsSet;
}

void OpenAPIAndAppSubmitCrossChainOrder::unsetFromAddress() {
  m_FromAddressIsSet = false;
}
double OpenAPIAndAppSubmitCrossChainOrder::getFromAmount() const {
  return m_FromAmount;
}

void OpenAPIAndAppSubmitCrossChainOrder::setFromAmount(double value) {
  m_FromAmount = value;
  m_FromAmountIsSet = true;
}

bool OpenAPIAndAppSubmitCrossChainOrder::fromAmountIsSet() const {
  return m_FromAmountIsSet;
}

void OpenAPIAndAppSubmitCrossChainOrder::unsetFromAmount() {
  m_FromAmountIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitCrossChainOrder::getFromChain() const {
  return m_FromChain;
}

void OpenAPIAndAppSubmitCrossChainOrder::setFromChain(
    const utility::string_t &value) {
  m_FromChain = value;
  m_FromChainIsSet = true;
}

bool OpenAPIAndAppSubmitCrossChainOrder::fromChainIsSet() const {
  return m_FromChainIsSet;
}

void OpenAPIAndAppSubmitCrossChainOrder::unsetFromChain() {
  m_FromChainIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitCrossChainOrder::getFromToken() const {
  return m_FromToken;
}

void OpenAPIAndAppSubmitCrossChainOrder::setFromToken(
    const utility::string_t &value) {
  m_FromToken = value;
  m_FromTokenIsSet = true;
}

bool OpenAPIAndAppSubmitCrossChainOrder::fromTokenIsSet() const {
  return m_FromTokenIsSet;
}

void OpenAPIAndAppSubmitCrossChainOrder::unsetFromToken() {
  m_FromTokenIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitCrossChainOrder::getToChain() const {
  return m_ToChain;
}

void OpenAPIAndAppSubmitCrossChainOrder::setToChain(
    const utility::string_t &value) {
  m_ToChain = value;
  m_ToChainIsSet = true;
}

bool OpenAPIAndAppSubmitCrossChainOrder::toChainIsSet() const {
  return m_ToChainIsSet;
}

void OpenAPIAndAppSubmitCrossChainOrder::unsetToChain() {
  m_ToChainIsSet = false;
}
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
