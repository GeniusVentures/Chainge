/**
 * Open API
 * Open API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: liuxiaobin@chainge.finance
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.5.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/OpenAPIInquiryParameters.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

OpenAPIInquiryParameters::OpenAPIInquiryParameters() {
  m_FeeLevel = 0;
  m_FeeLevelIsSet = false;
  m_FromAmount = 0.0;
  m_FromAmountIsSet = false;
  m_FromChain = utility::conversions::to_string_t("");
  m_FromChainIsSet = false;
  m_FromToken = utility::conversions::to_string_t("");
  m_FromTokenIsSet = false;
  m_ToChain = utility::conversions::to_string_t("");
  m_ToChainIsSet = false;
  m_ToToken = utility::conversions::to_string_t("");
  m_ToTokenIsSet = false;
}

OpenAPIInquiryParameters::~OpenAPIInquiryParameters() {}

void OpenAPIInquiryParameters::validate() {
  // TODO: implement validation
}

web::json::value OpenAPIInquiryParameters::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_FeeLevelIsSet) {
    val[utility::conversions::to_string_t(U("feeLevel"))] =
        ModelBase::toJson(m_FeeLevel);
  }
  if (m_FromAmountIsSet) {
    val[utility::conversions::to_string_t(U("fromAmount"))] =
        ModelBase::toJson(m_FromAmount);
  }
  if (m_FromChainIsSet) {
    val[utility::conversions::to_string_t(U("fromChain"))] =
        ModelBase::toJson(m_FromChain);
  }
  if (m_FromTokenIsSet) {
    val[utility::conversions::to_string_t(U("fromToken"))] =
        ModelBase::toJson(m_FromToken);
  }
  if (m_ToChainIsSet) {
    val[utility::conversions::to_string_t(U("toChain"))] =
        ModelBase::toJson(m_ToChain);
  }
  if (m_ToTokenIsSet) {
    val[utility::conversions::to_string_t(U("toToken"))] =
        ModelBase::toJson(m_ToToken);
  }

  return val;
}

bool OpenAPIInquiryParameters::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("feeLevel")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("feeLevel")));
    if (!fieldValue.is_null()) {
      int32_t refVal_setFeeLevel;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFeeLevel);
      setFeeLevel(refVal_setFeeLevel);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromAmount")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromAmount")));
    if (!fieldValue.is_null()) {
      double refVal_setFromAmount;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromAmount);
      setFromAmount(refVal_setFromAmount);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromChain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromChain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromChain);
      setFromChain(refVal_setFromChain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromToken")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromToken")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromToken;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromToken);
      setFromToken(refVal_setFromToken);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("toChain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("toChain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToChain);
      setToChain(refVal_setToChain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("toToken")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("toToken")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToToken;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToToken);
      setToToken(refVal_setToToken);
    }
  }
  return ok;
}

void OpenAPIInquiryParameters::toMultipart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_FeeLevelIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("feeLevel")),
        m_FeeLevel));
  }
  if (m_FromAmountIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromAmount")),
        m_FromAmount));
  }
  if (m_FromChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromChain")),
        m_FromChain));
  }
  if (m_FromTokenIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromToken")),
        m_FromToken));
  }
  if (m_ToChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("toChain")),
        m_ToChain));
  }
  if (m_ToTokenIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("toToken")),
        m_ToToken));
  }
}

bool OpenAPIInquiryParameters::fromMultiPart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("feeLevel")))) {
    int32_t refVal_setFeeLevel;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("feeLevel"))),
        refVal_setFeeLevel);
    setFeeLevel(refVal_setFeeLevel);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromAmount")))) {
    double refVal_setFromAmount;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromAmount"))),
        refVal_setFromAmount);
    setFromAmount(refVal_setFromAmount);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromChain")))) {
    utility::string_t refVal_setFromChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromChain"))),
        refVal_setFromChain);
    setFromChain(refVal_setFromChain);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromToken")))) {
    utility::string_t refVal_setFromToken;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromToken"))),
        refVal_setFromToken);
    setFromToken(refVal_setFromToken);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("toChain")))) {
    utility::string_t refVal_setToChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("toChain"))),
        refVal_setToChain);
    setToChain(refVal_setToChain);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("toToken")))) {
    utility::string_t refVal_setToToken;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("toToken"))),
        refVal_setToToken);
    setToToken(refVal_setToToken);
  }
  return ok;
}

int32_t OpenAPIInquiryParameters::getFeeLevel() const { return m_FeeLevel; }

void OpenAPIInquiryParameters::setFeeLevel(int32_t value) {
  m_FeeLevel = value;
  m_FeeLevelIsSet = true;
}

bool OpenAPIInquiryParameters::feeLevelIsSet() const { return m_FeeLevelIsSet; }

void OpenAPIInquiryParameters::unsetFeeLevel() { m_FeeLevelIsSet = false; }
double OpenAPIInquiryParameters::getFromAmount() const { return m_FromAmount; }

void OpenAPIInquiryParameters::setFromAmount(double value) {
  m_FromAmount = value;
  m_FromAmountIsSet = true;
}

bool OpenAPIInquiryParameters::fromAmountIsSet() const {
  return m_FromAmountIsSet;
}

void OpenAPIInquiryParameters::unsetFromAmount() { m_FromAmountIsSet = false; }
utility::string_t OpenAPIInquiryParameters::getFromChain() const {
  return m_FromChain;
}

void OpenAPIInquiryParameters::setFromChain(const utility::string_t &value) {
  m_FromChain = value;
  m_FromChainIsSet = true;
}

bool OpenAPIInquiryParameters::fromChainIsSet() const {
  return m_FromChainIsSet;
}

void OpenAPIInquiryParameters::unsetFromChain() { m_FromChainIsSet = false; }
utility::string_t OpenAPIInquiryParameters::getFromToken() const {
  return m_FromToken;
}

void OpenAPIInquiryParameters::setFromToken(const utility::string_t &value) {
  m_FromToken = value;
  m_FromTokenIsSet = true;
}

bool OpenAPIInquiryParameters::fromTokenIsSet() const {
  return m_FromTokenIsSet;
}

void OpenAPIInquiryParameters::unsetFromToken() { m_FromTokenIsSet = false; }
utility::string_t OpenAPIInquiryParameters::getToChain() const {
  return m_ToChain;
}

void OpenAPIInquiryParameters::setToChain(const utility::string_t &value) {
  m_ToChain = value;
  m_ToChainIsSet = true;
}

bool OpenAPIInquiryParameters::toChainIsSet() const { return m_ToChainIsSet; }

void OpenAPIInquiryParameters::unsetToChain() { m_ToChainIsSet = false; }
utility::string_t OpenAPIInquiryParameters::getToToken() const {
  return m_ToToken;
}

void OpenAPIInquiryParameters::setToToken(const utility::string_t &value) {
  m_ToToken = value;
  m_ToTokenIsSet = true;
}

bool OpenAPIInquiryParameters::toTokenIsSet() const { return m_ToTokenIsSet; }

void OpenAPIInquiryParameters::unsetToToken() { m_ToTokenIsSet = false; }
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
