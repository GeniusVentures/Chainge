/**
 * Open API
 * Open API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: liuxiaobin@chainge.finance
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.5.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/OpenAPIAndAppSubmissionToObtainAggregate.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

OpenAPIAndAppSubmissionToObtainAggregate::
    OpenAPIAndAppSubmissionToObtainAggregate() {
  m_Amount = 0.0;
  m_AmountIsSet = false;
  m_Chain = utility::conversions::to_string_t("");
  m_ChainIsSet = false;
  m_EvmAddress = utility::conversions::to_string_t("");
  m_EvmAddressIsSet = false;
  m_FromAddress = utility::conversions::to_string_t("");
  m_FromAddressIsSet = false;
  m_Token = utility::conversions::to_string_t("");
  m_TokenIsSet = false;
}

OpenAPIAndAppSubmissionToObtainAggregate::
    ~OpenAPIAndAppSubmissionToObtainAggregate() {}

void OpenAPIAndAppSubmissionToObtainAggregate::validate() {
  // TODO: implement validation
}

web::json::value OpenAPIAndAppSubmissionToObtainAggregate::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_AmountIsSet) {
    val[utility::conversions::to_string_t(U("amount"))] =
        ModelBase::toJson(m_Amount);
  }
  if (m_ChainIsSet) {
    val[utility::conversions::to_string_t(U("chain"))] =
        ModelBase::toJson(m_Chain);
  }
  if (m_EvmAddressIsSet) {
    val[utility::conversions::to_string_t(U("evmAddress"))] =
        ModelBase::toJson(m_EvmAddress);
  }
  if (m_FromAddressIsSet) {
    val[utility::conversions::to_string_t(U("fromAddress"))] =
        ModelBase::toJson(m_FromAddress);
  }
  if (m_TokenIsSet) {
    val[utility::conversions::to_string_t(U("token"))] =
        ModelBase::toJson(m_Token);
  }

  return val;
}

bool OpenAPIAndAppSubmissionToObtainAggregate::fromJson(
    const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("amount")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("amount")));
    if (!fieldValue.is_null()) {
      double refVal_setAmount;
      ok &= ModelBase::fromJson(fieldValue, refVal_setAmount);
      setAmount(refVal_setAmount);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("chain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("chain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setChain);
      setChain(refVal_setChain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("evmAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("evmAddress")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setEvmAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setEvmAddress);
      setEvmAddress(refVal_setEvmAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromAddress")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromAddress);
      setFromAddress(refVal_setFromAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("token")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("token")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToken;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToken);
      setToken(refVal_setToken);
    }
  }
  return ok;
}

void OpenAPIAndAppSubmissionToObtainAggregate::toMultipart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_AmountIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("amount")), m_Amount));
  }
  if (m_ChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("chain")), m_Chain));
  }
  if (m_EvmAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("evmAddress")),
        m_EvmAddress));
  }
  if (m_FromAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromAddress")),
        m_FromAddress));
  }
  if (m_TokenIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("token")), m_Token));
  }
}

bool OpenAPIAndAppSubmissionToObtainAggregate::fromMultiPart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("amount")))) {
    double refVal_setAmount;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("amount"))),
        refVal_setAmount);
    setAmount(refVal_setAmount);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("chain")))) {
    utility::string_t refVal_setChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("chain"))),
        refVal_setChain);
    setChain(refVal_setChain);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("evmAddress")))) {
    utility::string_t refVal_setEvmAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("evmAddress"))),
        refVal_setEvmAddress);
    setEvmAddress(refVal_setEvmAddress);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromAddress")))) {
    utility::string_t refVal_setFromAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromAddress"))),
        refVal_setFromAddress);
    setFromAddress(refVal_setFromAddress);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("token")))) {
    utility::string_t refVal_setToken;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("token"))),
        refVal_setToken);
    setToken(refVal_setToken);
  }
  return ok;
}

double OpenAPIAndAppSubmissionToObtainAggregate::getAmount() const {
  return m_Amount;
}

void OpenAPIAndAppSubmissionToObtainAggregate::setAmount(double value) {
  m_Amount = value;
  m_AmountIsSet = true;
}

bool OpenAPIAndAppSubmissionToObtainAggregate::amountIsSet() const {
  return m_AmountIsSet;
}

void OpenAPIAndAppSubmissionToObtainAggregate::unsetAmount() {
  m_AmountIsSet = false;
}
utility::string_t OpenAPIAndAppSubmissionToObtainAggregate::getChain() const {
  return m_Chain;
}

void OpenAPIAndAppSubmissionToObtainAggregate::setChain(
    const utility::string_t &value) {
  m_Chain = value;
  m_ChainIsSet = true;
}

bool OpenAPIAndAppSubmissionToObtainAggregate::chainIsSet() const {
  return m_ChainIsSet;
}

void OpenAPIAndAppSubmissionToObtainAggregate::unsetChain() {
  m_ChainIsSet = false;
}
utility::string_t
OpenAPIAndAppSubmissionToObtainAggregate::getEvmAddress() const {
  return m_EvmAddress;
}

void OpenAPIAndAppSubmissionToObtainAggregate::setEvmAddress(
    const utility::string_t &value) {
  m_EvmAddress = value;
  m_EvmAddressIsSet = true;
}

bool OpenAPIAndAppSubmissionToObtainAggregate::evmAddressIsSet() const {
  return m_EvmAddressIsSet;
}

void OpenAPIAndAppSubmissionToObtainAggregate::unsetEvmAddress() {
  m_EvmAddressIsSet = false;
}
utility::string_t
OpenAPIAndAppSubmissionToObtainAggregate::getFromAddress() const {
  return m_FromAddress;
}

void OpenAPIAndAppSubmissionToObtainAggregate::setFromAddress(
    const utility::string_t &value) {
  m_FromAddress = value;
  m_FromAddressIsSet = true;
}

bool OpenAPIAndAppSubmissionToObtainAggregate::fromAddressIsSet() const {
  return m_FromAddressIsSet;
}

void OpenAPIAndAppSubmissionToObtainAggregate::unsetFromAddress() {
  m_FromAddressIsSet = false;
}
utility::string_t OpenAPIAndAppSubmissionToObtainAggregate::getToken() const {
  return m_Token;
}

void OpenAPIAndAppSubmissionToObtainAggregate::setToken(
    const utility::string_t &value) {
  m_Token = value;
  m_TokenIsSet = true;
}

bool OpenAPIAndAppSubmissionToObtainAggregate::tokenIsSet() const {
  return m_TokenIsSet;
}

void OpenAPIAndAppSubmissionToObtainAggregate::unsetToken() {
  m_TokenIsSet = false;
}
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
