/**
 * Open API
 * Open API
 *
 * The version of the OpenAPI document: 1.0
 * Contact: liuxiaobin@chainge.finance
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.5.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "CppRestOpenAPIClient/model/OpenAPIAndAppSubmitAggregateOrder.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

OpenAPIAndAppSubmitAggregateOrder::OpenAPIAndAppSubmitAggregateOrder() {
  m_CertHash = utility::conversions::to_string_t("");
  m_CertHashIsSet = false;
  m_EvmAddress = utility::conversions::to_string_t("");
  m_EvmAddressIsSet = false;
  m_FeeLevel = 0;
  m_FeeLevelIsSet = false;
  m_FromAddress = utility::conversions::to_string_t("");
  m_FromAddressIsSet = false;
  m_FromAmount = 0.0;
  m_FromAmountIsSet = false;
  m_FromChain = utility::conversions::to_string_t("");
  m_FromChainIsSet = false;
  m_FromPublicKey = utility::conversions::to_string_t("");
  m_FromPublicKeyIsSet = false;
  m_FromToken = utility::conversions::to_string_t("");
  m_FromTokenIsSet = false;
  m_ToAddress = utility::conversions::to_string_t("");
  m_ToAddressIsSet = false;
  m_ToAmount = 0.0;
  m_ToAmountIsSet = false;
  m_ToChain = utility::conversions::to_string_t("");
  m_ToChainIsSet = false;
  m_ToToken = utility::conversions::to_string_t("");
  m_ToTokenIsSet = false;
}

OpenAPIAndAppSubmitAggregateOrder::~OpenAPIAndAppSubmitAggregateOrder() {}

void OpenAPIAndAppSubmitAggregateOrder::validate() {
  // TODO: implement validation
}

web::json::value OpenAPIAndAppSubmitAggregateOrder::toJson() const {

  web::json::value val = web::json::value::object();

  if (m_CertHashIsSet) {
    val[utility::conversions::to_string_t(U("certHash"))] =
        ModelBase::toJson(m_CertHash);
  }
  if (m_EvmAddressIsSet) {
    val[utility::conversions::to_string_t(U("evmAddress"))] =
        ModelBase::toJson(m_EvmAddress);
  }
  if (m_FeeLevelIsSet) {
    val[utility::conversions::to_string_t(U("feeLevel"))] =
        ModelBase::toJson(m_FeeLevel);
  }
  if (m_FromAddressIsSet) {
    val[utility::conversions::to_string_t(U("fromAddress"))] =
        ModelBase::toJson(m_FromAddress);
  }
  if (m_FromAmountIsSet) {
    val[utility::conversions::to_string_t(U("fromAmount"))] =
        ModelBase::toJson(m_FromAmount);
  }
  if (m_FromChainIsSet) {
    val[utility::conversions::to_string_t(U("fromChain"))] =
        ModelBase::toJson(m_FromChain);
  }
  if (m_FromPublicKeyIsSet) {
    val[utility::conversions::to_string_t(U("fromPublicKey"))] =
        ModelBase::toJson(m_FromPublicKey);
  }
  if (m_FromTokenIsSet) {
    val[utility::conversions::to_string_t(U("fromToken"))] =
        ModelBase::toJson(m_FromToken);
  }
  if (m_ToAddressIsSet) {
    val[utility::conversions::to_string_t(U("toAddress"))] =
        ModelBase::toJson(m_ToAddress);
  }
  if (m_ToAmountIsSet) {
    val[utility::conversions::to_string_t(U("toAmount"))] =
        ModelBase::toJson(m_ToAmount);
  }
  if (m_ToChainIsSet) {
    val[utility::conversions::to_string_t(U("toChain"))] =
        ModelBase::toJson(m_ToChain);
  }
  if (m_ToTokenIsSet) {
    val[utility::conversions::to_string_t(U("toToken"))] =
        ModelBase::toJson(m_ToToken);
  }

  return val;
}

bool OpenAPIAndAppSubmitAggregateOrder::fromJson(const web::json::value &val) {
  bool ok = true;

  if (val.has_field(utility::conversions::to_string_t(U("certHash")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("certHash")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setCertHash;
      ok &= ModelBase::fromJson(fieldValue, refVal_setCertHash);
      setCertHash(refVal_setCertHash);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("evmAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("evmAddress")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setEvmAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setEvmAddress);
      setEvmAddress(refVal_setEvmAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("feeLevel")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("feeLevel")));
    if (!fieldValue.is_null()) {
      int32_t refVal_setFeeLevel;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFeeLevel);
      setFeeLevel(refVal_setFeeLevel);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromAddress")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromAddress);
      setFromAddress(refVal_setFromAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromAmount")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromAmount")));
    if (!fieldValue.is_null()) {
      double refVal_setFromAmount;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromAmount);
      setFromAmount(refVal_setFromAmount);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromChain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromChain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromChain);
      setFromChain(refVal_setFromChain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromPublicKey")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromPublicKey")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromPublicKey;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromPublicKey);
      setFromPublicKey(refVal_setFromPublicKey);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("fromToken")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("fromToken")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setFromToken;
      ok &= ModelBase::fromJson(fieldValue, refVal_setFromToken);
      setFromToken(refVal_setFromToken);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("toAddress")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("toAddress")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToAddress;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToAddress);
      setToAddress(refVal_setToAddress);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("toAmount")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("toAmount")));
    if (!fieldValue.is_null()) {
      double refVal_setToAmount;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToAmount);
      setToAmount(refVal_setToAmount);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("toChain")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("toChain")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToChain;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToChain);
      setToChain(refVal_setToChain);
    }
  }
  if (val.has_field(utility::conversions::to_string_t(U("toToken")))) {
    const web::json::value &fieldValue =
        val.at(utility::conversions::to_string_t(U("toToken")));
    if (!fieldValue.is_null()) {
      utility::string_t refVal_setToToken;
      ok &= ModelBase::fromJson(fieldValue, refVal_setToToken);
      setToToken(refVal_setToToken);
    }
  }
  return ok;
}

void OpenAPIAndAppSubmitAggregateOrder::toMultipart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) const {
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }
  if (m_CertHashIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("certHash")),
        m_CertHash));
  }
  if (m_EvmAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("evmAddress")),
        m_EvmAddress));
  }
  if (m_FeeLevelIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("feeLevel")),
        m_FeeLevel));
  }
  if (m_FromAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromAddress")),
        m_FromAddress));
  }
  if (m_FromAmountIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromAmount")),
        m_FromAmount));
  }
  if (m_FromChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromChain")),
        m_FromChain));
  }
  if (m_FromPublicKeyIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromPublicKey")),
        m_FromPublicKey));
  }
  if (m_FromTokenIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("fromToken")),
        m_FromToken));
  }
  if (m_ToAddressIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("toAddress")),
        m_ToAddress));
  }
  if (m_ToAmountIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("toAmount")),
        m_ToAmount));
  }
  if (m_ToChainIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("toChain")),
        m_ToChain));
  }
  if (m_ToTokenIsSet) {
    multipart->add(ModelBase::toHttpContent(
        namePrefix + utility::conversions::to_string_t(U("toToken")),
        m_ToToken));
  }
}

bool OpenAPIAndAppSubmitAggregateOrder::fromMultiPart(
    std::shared_ptr<MultipartFormData> multipart,
    const utility::string_t &prefix) {
  bool ok = true;
  utility::string_t namePrefix = prefix;
  if (namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) !=
                                   utility::conversions::to_string_t(U("."))) {
    namePrefix += utility::conversions::to_string_t(U("."));
  }

  if (multipart->hasContent(utility::conversions::to_string_t(U("certHash")))) {
    utility::string_t refVal_setCertHash;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("certHash"))),
        refVal_setCertHash);
    setCertHash(refVal_setCertHash);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("evmAddress")))) {
    utility::string_t refVal_setEvmAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("evmAddress"))),
        refVal_setEvmAddress);
    setEvmAddress(refVal_setEvmAddress);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("feeLevel")))) {
    int32_t refVal_setFeeLevel;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("feeLevel"))),
        refVal_setFeeLevel);
    setFeeLevel(refVal_setFeeLevel);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromAddress")))) {
    utility::string_t refVal_setFromAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromAddress"))),
        refVal_setFromAddress);
    setFromAddress(refVal_setFromAddress);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromAmount")))) {
    double refVal_setFromAmount;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromAmount"))),
        refVal_setFromAmount);
    setFromAmount(refVal_setFromAmount);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromChain")))) {
    utility::string_t refVal_setFromChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromChain"))),
        refVal_setFromChain);
    setFromChain(refVal_setFromChain);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromPublicKey")))) {
    utility::string_t refVal_setFromPublicKey;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromPublicKey"))),
        refVal_setFromPublicKey);
    setFromPublicKey(refVal_setFromPublicKey);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("fromToken")))) {
    utility::string_t refVal_setFromToken;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("fromToken"))),
        refVal_setFromToken);
    setFromToken(refVal_setFromToken);
  }
  if (multipart->hasContent(
          utility::conversions::to_string_t(U("toAddress")))) {
    utility::string_t refVal_setToAddress;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(
            utility::conversions::to_string_t(U("toAddress"))),
        refVal_setToAddress);
    setToAddress(refVal_setToAddress);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("toAmount")))) {
    double refVal_setToAmount;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("toAmount"))),
        refVal_setToAmount);
    setToAmount(refVal_setToAmount);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("toChain")))) {
    utility::string_t refVal_setToChain;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("toChain"))),
        refVal_setToChain);
    setToChain(refVal_setToChain);
  }
  if (multipart->hasContent(utility::conversions::to_string_t(U("toToken")))) {
    utility::string_t refVal_setToToken;
    ok &= ModelBase::fromHttpContent(
        multipart->getContent(utility::conversions::to_string_t(U("toToken"))),
        refVal_setToToken);
    setToToken(refVal_setToToken);
  }
  return ok;
}

utility::string_t OpenAPIAndAppSubmitAggregateOrder::getCertHash() const {
  return m_CertHash;
}

void OpenAPIAndAppSubmitAggregateOrder::setCertHash(
    const utility::string_t &value) {
  m_CertHash = value;
  m_CertHashIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::certHashIsSet() const {
  return m_CertHashIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetCertHash() {
  m_CertHashIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitAggregateOrder::getEvmAddress() const {
  return m_EvmAddress;
}

void OpenAPIAndAppSubmitAggregateOrder::setEvmAddress(
    const utility::string_t &value) {
  m_EvmAddress = value;
  m_EvmAddressIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::evmAddressIsSet() const {
  return m_EvmAddressIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetEvmAddress() {
  m_EvmAddressIsSet = false;
}
int32_t OpenAPIAndAppSubmitAggregateOrder::getFeeLevel() const {
  return m_FeeLevel;
}

void OpenAPIAndAppSubmitAggregateOrder::setFeeLevel(int32_t value) {
  m_FeeLevel = value;
  m_FeeLevelIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::feeLevelIsSet() const {
  return m_FeeLevelIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetFeeLevel() {
  m_FeeLevelIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitAggregateOrder::getFromAddress() const {
  return m_FromAddress;
}

void OpenAPIAndAppSubmitAggregateOrder::setFromAddress(
    const utility::string_t &value) {
  m_FromAddress = value;
  m_FromAddressIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::fromAddressIsSet() const {
  return m_FromAddressIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetFromAddress() {
  m_FromAddressIsSet = false;
}
double OpenAPIAndAppSubmitAggregateOrder::getFromAmount() const {
  return m_FromAmount;
}

void OpenAPIAndAppSubmitAggregateOrder::setFromAmount(double value) {
  m_FromAmount = value;
  m_FromAmountIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::fromAmountIsSet() const {
  return m_FromAmountIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetFromAmount() {
  m_FromAmountIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitAggregateOrder::getFromChain() const {
  return m_FromChain;
}

void OpenAPIAndAppSubmitAggregateOrder::setFromChain(
    const utility::string_t &value) {
  m_FromChain = value;
  m_FromChainIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::fromChainIsSet() const {
  return m_FromChainIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetFromChain() {
  m_FromChainIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitAggregateOrder::getFromPublicKey() const {
  return m_FromPublicKey;
}

void OpenAPIAndAppSubmitAggregateOrder::setFromPublicKey(
    const utility::string_t &value) {
  m_FromPublicKey = value;
  m_FromPublicKeyIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::fromPublicKeyIsSet() const {
  return m_FromPublicKeyIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetFromPublicKey() {
  m_FromPublicKeyIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitAggregateOrder::getFromToken() const {
  return m_FromToken;
}

void OpenAPIAndAppSubmitAggregateOrder::setFromToken(
    const utility::string_t &value) {
  m_FromToken = value;
  m_FromTokenIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::fromTokenIsSet() const {
  return m_FromTokenIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetFromToken() {
  m_FromTokenIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitAggregateOrder::getToAddress() const {
  return m_ToAddress;
}

void OpenAPIAndAppSubmitAggregateOrder::setToAddress(
    const utility::string_t &value) {
  m_ToAddress = value;
  m_ToAddressIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::toAddressIsSet() const {
  return m_ToAddressIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetToAddress() {
  m_ToAddressIsSet = false;
}
double OpenAPIAndAppSubmitAggregateOrder::getToAmount() const {
  return m_ToAmount;
}

void OpenAPIAndAppSubmitAggregateOrder::setToAmount(double value) {
  m_ToAmount = value;
  m_ToAmountIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::toAmountIsSet() const {
  return m_ToAmountIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetToAmount() {
  m_ToAmountIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitAggregateOrder::getToChain() const {
  return m_ToChain;
}

void OpenAPIAndAppSubmitAggregateOrder::setToChain(
    const utility::string_t &value) {
  m_ToChain = value;
  m_ToChainIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::toChainIsSet() const {
  return m_ToChainIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetToChain() {
  m_ToChainIsSet = false;
}
utility::string_t OpenAPIAndAppSubmitAggregateOrder::getToToken() const {
  return m_ToToken;
}

void OpenAPIAndAppSubmitAggregateOrder::setToToken(
    const utility::string_t &value) {
  m_ToToken = value;
  m_ToTokenIsSet = true;
}

bool OpenAPIAndAppSubmitAggregateOrder::toTokenIsSet() const {
  return m_ToTokenIsSet;
}

void OpenAPIAndAppSubmitAggregateOrder::unsetToToken() {
  m_ToTokenIsSet = false;
}
} // namespace model
} // namespace client
} // namespace openapitools
} // namespace org
